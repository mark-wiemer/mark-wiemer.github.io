{"version":3,"sources":["ConstructionAlert.tsx","Navigation.tsx","ts/rules.ts","pages/Home.tsx","pages/About.tsx","Latex.tsx","pages/classes/alg/01_preliminaries/IntegerExponents.tsx","pages/classes/alg/Preliminaries.tsx","pages/classes/Algebra.tsx","ts/mathwm.ts","pages/Sandbox.tsx","Routes.tsx","App.tsx","index.tsx"],"names":["ConstructionAlert","useState","show","setShow","Alert","variant","onClose","dismissible","Navigation","RuleID","props","routes","map","element","link","basePath","fullPath","path","key","id","component","to","name","children","child","Home","href","About","Latex","Provider","Node","inline","formula","content","IntegerExponents","Preliminaries","Algebra","RULES","None","func","n","Arithmetic","node","arithmeticEvaluation","evaluate","toString","indexOf","ProductOfOneVariable","op","args","leftVariable","rightVariable","undefined","leftExponent","value","rightExponent","nodeStr","mathjs","latex","PowerToPower","lowerExpNode","base","lowerPower","upperPower","newMathText","COUNT_MINUS_ONE","arithmetic","resultString","err","applyRule","rule","transform","rules","texToMath","tex","split","join","tryParse","mathText","trim","addStyles","StatefulSandbox","mathField","onChange","updateState","mathQuillDidMount","evaluationSteps","mathwm","state","steps","ruleID","done","lastNode","length","i","transformed","push","step","s","this","text","evaluation","mathquillDidMount","React","Component","Sandbox","RouteObject","routeObjects","pathTo404","potentialPath","pathHelper","partialPath","routeObject","childrenResult","Routes","recursiveRoute","exact","route","App","render","document","getElementById"],"mappings":"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","file":"static/js/main.2974a76b.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport Alert from 'react-bootstrap/Alert';\n\nconst ConstructionAlert = (): JSX.Element => {\n  const [show, setShow] = useState(true);\n\n  return show ? (\n    <Alert variant=\"primary\" onClose={() => setShow(false)} dismissible>\n      This site is under construction.\n    </Alert>\n  ) : (\n    <></>\n  );\n};\n\nexport default ConstructionAlert;\n","import React from 'react';\nimport { Link } from 'react-router-dom';\nimport { RouteObject } from './Routes';\n\n/**\n * Generates nested, unordered list of internal links\n */\nconst Navigation = (props: { routes: RouteObject[] }): JSX.Element => (\n  <nav>\n    <ul>{props.routes.map(element => link(element, ''))}</ul>\n  </nav>\n);\n\n/** Returns component to be rendered */\nfunction link(element: RouteObject, basePath: string): JSX.Element {\n  let fullPath = `${basePath}/${element.path}`;\n  return (\n    <li key={element.id}>\n      {element.component ? (\n        <Link to={fullPath}>{element.name}</Link>\n      ) : (\n        element.name\n      )}\n      <ul>{element.children.map(child => link(child, fullPath))}</ul>\n    </li>\n  );\n}\n\nexport default Navigation;\n","import * as mathjs from 'mathjs';\n\nimport { MathNode, evaluate } from './mathwm';\n\n// TODO should be const? const makes for difficult iteration\nexport enum RuleID {\n  None, // should always be first\n  Arithmetic, // should always be second\n  ProductOfOneVariable,\n  PowerToPower,\n  COUNT_MINUS_ONE, // only used as metadata, always last\n}\n\nexport interface Rule {\n  func: (n: MathNode) => MathNode;\n  name: string;\n  latex?: string;\n}\n\nexport const RULES: Record<RuleID, Rule> = {\n  [RuleID.None]: {\n    func: (n) => n,\n    name: 'Initial expression',\n  },\n  [RuleID.Arithmetic]: {\n    func: evaluateArithmetic,\n    name: 'Arithmetic',\n  },\n  [RuleID.ProductOfOneVariable]: {\n    func: productOfOneVariable,\n    name: 'Product of one Variable',\n    latex: 'a^b\\\\cdot a^c=a^{b+c}',\n  },\n  [RuleID.PowerToPower]: {\n    func: powerToPower,\n    name: 'Power to power',\n    latex: '\\\\left(a^b\\\\right)^c=a^{bc}',\n  },\n  [RuleID.COUNT_MINUS_ONE]: {\n    func: (n) => n,\n    name: 'N/A',\n  },\n};\n\n/**\n * Evaluates non-division arithmetic inside an algebraic expression. Does not do any\n * algebraic evaluation.\n * @param node the expression to evaluate\n * @return the arithmetically evaluated expression\n */\nexport function evaluateArithmetic(node: MathNode): MathNode {\n  // if can be arithmetically evaluated\n  // and none of its children are division nodes\n  let arithmeticEvaluation = evaluate(node, true);\n  let noDivision = node.toString().indexOf('/') === -1;\n  if (noDivision) {\n    return arithmeticEvaluation;\n  } else {\n    return node;\n  }\n}\n\n/**\n * Transforms a product of two exponentiations into a base to the power of a sum\n * (a ^ b) ^ c -> a ^ (b + c)\n * If `node` is not a product of two exponentiations, does nothing\n * @param node the expression to evaluate\n * @return if `node` is product of two exponentiations, returns transformed\n * expression, else returns `node`.\n */\nfunction productOfOneVariable(node: MathNode): MathNode {\n  // If this is a product of two exponentiations (nominal case)\n  if (\n    node.op === '*' &&\n    node.args?.[0].op === '^' &&\n    node.args?.[1].op === '^'\n  ) {\n    let leftVariable = node.args?.[0].args?.[0].name;\n    let rightVariable = node.args?.[1].args?.[0].name;\n    // If both variables are defined and equal, assume\n    if (leftVariable !== undefined && leftVariable === rightVariable) {\n      let leftExponent: number = node.args?.[0].args?.[1].value;\n      let rightExponent: number = node.args?.[1].args?.[1].value;\n      let nodeStr = `${leftVariable} ^ (${leftExponent} + ${rightExponent})`;\n      return mathjs.parse(nodeStr);\n    }\n  }\n  return node;\n}\n\n/**\n * Transforms a power tower with two powers to a base to the power of a product\n * (a ^ b) ^ c -> a ^ (b * c)\n * If `node` is not a power tower, does nothing\n * @param node the expression to evaluate\n * @return if `node` is a power tower with two powers, returns transformed\n * expression, else returns `node`.\n */\nfunction powerToPower(node: MathNode): MathNode {\n  if (node.op === '^' && node.args?.[0].content?.op === '^') {\n    let lowerExpNode = node.args?.[0].content;\n    let base: string = `${lowerExpNode.args?.[0].toString()}`;\n    let lowerPower: string = `${lowerExpNode.args?.[1].toString()}`;\n    let upperPower: string = `${node.args?.[1]}`;\n    let newMathText = `${base} ^ (${lowerPower} * ${upperPower})`;\n    return mathjs.parse(newMathText);\n  }\n  return node;\n}\n","import React from 'react';\n\nconst Home = (): JSX.Element => (\n  <div>\n    <h2>Home</h2>\n    <p>Free, accessible, interactive math lessons.</p>\n    <p>This site is under construction.</p>\n    <p>\n      Check out{' '}\n      <a href=\"https://github.com/mark-wiemer/math-with-mark\">\n        the repository on GitHub\n      </a>{' '}\n      for more information.\n    </p>\n    <p>Last updated 2020-10-01 00:31 PDT</p>\n  </div>\n);\n\nexport default Home;\n","import React from 'react';\n\nconst About = (): JSX.Element => (\n  <div>\n    <h2>About</h2>\n    <p>\n      Hi, my name is Mark. I'm a math tutor at University of Wisconsin-Madison,\n      and I want to create a site to better serve students struggling in math.\n    </p>\n    <p>\n      This site offers supplemental learning material that I believe is\n      difficult to find elsewhere. Primarily, I focus on abstract\n      problem-solving methods that can be applied to families of problems. With\n      the materials on my site, I aim to help students become unstuck while\n      completing assignments. In this way, I hope to empower students and\n      instill in them confidence in their abilities to tackle large, complex\n      problems.\n    </p>\n    <h3>Acknowledgements</h3>\n    <p>\n      The structure of the lessons on this site was heavily inspired by{' '}\n      <a href=\"https://tutorial.math.lamar.edu\">Paul Dawkins' online notes</a>.\n      Those notes have been an awesome reference for me, both as a student and\n      as a tutor.\n    </p>\n    <h3>Miscellaneous</h3>\n    <p>\n      If you find any issues, points of confusion, or weird behaviors with the\n      website, please{' '}\n      <a href=\"https://github.com/mark-wiemer/mark-wiemer.github.io/issues/new\">\n        contact me here\n      </a>{' '}\n      (a free GitHub account is required). I'm also open to any general feedback\n      about the site through that link.\n    </p>\n    <p>\n      Everything about this website is open source. For the techies out there,\n      you can view the GitHub repo{' '}\n      <a href=\"https://github.com/mark-wiemer/mark-wiemer.github.io\">here</a>.\n    </p>\n  </div>\n);\n\nexport default About;\n","import React from 'react';\nimport MathJax from 'react-mathjax';\n\nconst Latex = (props: LatexProps) => (\n  <MathJax.Provider>\n    <MathJax.Node inline={props.inline} formula={props.content} />\n  </MathJax.Provider>\n);\n\ninterface LatexProps {\n  content: string;\n  inline?: boolean;\n}\n\nexport default Latex;\n","import React from 'react';\n\nimport Latex from '../../../../Latex';\n\nconst IntegerExponents = (): JSX.Element => (\n  <div>\n    <h2>Algebra 1-1: Integer Exponents</h2>\n    <p>\n      Using exponents is very common in algebra. Just like multiplication is\n      repeated addition, exponentiation (the fancy math term for raising a\n      number to a power) is repeated multiplication.\n    </p>\n    <h3>Properties</h3>\n    <ol>\n      <li>\n        <Latex inline content={'a^ba^c = a^{b+c}'} />. For example,{' '}\n        <Latex inline content={'2^3\\\\cdot 2^4 = 2^7'} />\n      </li>\n    </ol>\n  </div>\n);\n\nexport default IntegerExponents;\n","import React from 'react';\nimport { path } from '../../../Routes';\nimport IntegerExponents from './01_preliminaries/IntegerExponents';\nimport { Link } from 'react-router-dom';\n\nconst Preliminaries = () => (\n  <div>\n    <h2>Preliminaries</h2>\n    <p>\n      In this chapter, we will cover topics that are essential to solving\n      algebraic problems. These topics might seem relatively simple, but they\n      are fundamental for the complex material covered in later chapters.\n    </p>\n    <ol>\n      <li>\n        <Link to={path(IntegerExponents)}>Integer Exponents</Link>: The\n        properties of exponents that are most common in algebraic expressions.\n        This section focuses on positive integers for simplicity, and other\n        exponent types are covered later.\n      </li>\n    </ol>\n  </div>\n);\n\nexport default Preliminaries;\n","import React from 'react';\nimport { Link, HashRouter } from 'react-router-dom';\nimport { path } from '../../Routes';\nimport Preliminaries from './alg/Preliminaries';\nimport IntegerExponents from './alg/01_preliminaries/IntegerExponents';\n\nconst Algebra = (): JSX.Element => (\n  <HashRouter>\n    <h2>Algebra</h2>\n    <p>\n      Algebra is the introduction to abstraction in math. Instead of writing all\n      values explicitly, some values are replaced with symbols to mark unknowns.\n      In this way, the core structure of the expression can be manipulated\n      without concern for the actual values. An understanding of these abstract\n      manipulations is key to success not only in mathematics, but also in\n      logic, philosophy, and communication.\n    </p>\n    <h3>\n      <Link to={path(Preliminaries)}>Preliminaries</Link>\n    </h3>\n    <p>\n      In this chapter we focus on properties of expressions used frequently in\n      algebra. This includes exponents, polynomials, rational expressions, and\n      complex numbers.\n    </p>\n    <ul>\n      <li>\n        <p>\n          <Link to={path(IntegerExponents)}>Integer Exponents</Link>: The\n          properties of exponents that are most common in algebraic expressions.\n        </p>\n      </li>\n    </ul>\n  </HashRouter>\n);\n\nexport default Algebra;\n","import * as mathjs from 'mathjs';\nimport * as rules from './rules';\n\n/** Type alias, we may change away from mathjs in the future */\nexport type MathNode = mathjs.MathNode;\n\n/** Used for functions that apply one rule to an expression and return the result */\ntype RuleApplicationFunction = (n: MathNode) => MathNode;\n\nexport interface Step {\n  node: MathNode;\n  ruleID: rules.RuleID;\n}\n\n/**\n * Returns the coefficient of terms of the form (COEFFICIENT)(SYMBOL)^(POWER).\n *\n * CONTRACT: Expression must be of the form \\sum{Ax^B}, A, B constant; x any\n * variable\n * @param root The root of the AST\n * @param variable The variable to evaluate\n * @param exponent The power to which the variable is raised\n */\nexport function coefficient(\n  root: MathNode,\n  variable: string,\n  exponent: number,\n): number {\n  // node is OperatorNode from contract, either '+' or '*'\n  let leftChild = args(root)[0];\n  let rightChild = args(root)[1];\n  if (root.op === '+') {\n    return (\n      coefficient(leftChild, variable, exponent) +\n      coefficient(rightChild, variable, exponent)\n    );\n  }\n  // op === '*', left child is coeff, right child is exp node\n  let actualVariable = args(rightChild)[0].name;\n  let actualExponent = args(rightChild)[1].value;\n  if (actualVariable === variable && actualExponent === exponent) {\n    return leftChild.value;\n  }\n  // not a match, this term does not contribute to coefficient\n  return 0;\n}\n\n/** Wrapper to simplify cast of node.args to MathNode[] */\nfunction args(node: MathNode): MathNode[] {\n  return node.args as MathNode[];\n}\n\n/**\n * Evaluate a given expression either arithmetically or algebraically\n * @param node The expression to evaluate\n * @param arithmetic True to evaluate as an arithmetic expression.\n * False for algebraic evaluation\n * @return the evaluation of the expression. If expression cannot be evaluated,\n * return original expression\n */\nexport function evaluate(node: MathNode, arithmetic: boolean): MathNode {\n  let func = arithmetic ? mathjs.evaluate : mathjs.simplify;\n  try {\n    // stringify, apply function, stringify result, parse stringified result\n    let resultString = func(node.toString()).toString();\n    return mathjs.parse(resultString);\n  } catch (err) {\n    return node;\n  }\n}\n\n/**\n * Applies the given rule to the given expression\n * @param node The expression\n * @param rule The rule to apply\n * @return the result of applying the given rule to the given expression.\n * If the given expression cannot be parsed or the rule cannot be applied,\n * returns `mathText` as given\n */\nexport function applyRule(node: MathNode, rule: rules.RuleID): MathNode {\n  return node.transform(rules.RULES[rule].func);\n}\n\nexport function texToMath(tex: string): string {\n  tex = tex.split('{').join('(');\n  tex = tex.split('}').join(')');\n  tex = tex.split('\\\\left').join('');\n  tex = tex.split('\\\\right').join('');\n  tex = tex.split(/\\\\cdot ?/).join(' * ');\n  return tex;\n}\n\nexport function tryParse(mathText: string): MathNode | null {\n  if (mathText.trim() === '') return null;\n  try {\n    let node = mathjs.parse(mathText);\n    return node;\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Returns the step-by-step evaluation of this node, as dictated by rules.\n * First element of the array is the node itself with the no-op rule.\n * Rules are applied in order (arithmetic first, then algebra)\n * If any rule transforms the node, it is used as the next step\n * Final node is not changed by any of the rule functions\n * @param node\n */\nexport function steps(node: MathNode): Step[] {\n  let steps: Step[] = [{ node, ruleID: rules.RuleID.None }];\n  let done = false;\n  while (!done) {\n    done = true; // assume no rule will further simplify the expression\n    let lastNode: MathNode = steps[steps.length - 1].node;\n    for (let i = 0; i < rules.RuleID.COUNT_MINUS_ONE; i++) {\n      let rule: rules.RuleID = i as rules.RuleID;\n      let transformed = applyRule(lastNode, rule);\n      if (transformed.toString() !== lastNode.toString()) {\n        done = false;\n        steps.push({ node: transformed, ruleID: rule });\n        break; // restart from beginning of list with new lastNode\n      }\n    }\n  }\n\n  return steps;\n}\n","import React from 'react';\nimport { addStyles, EditableMathField, MathField } from 'react-mathquill';\n\nimport * as mathwm from '../ts/mathwm';\nimport * as rules from '../ts/rules';\nimport Latex from '../Latex';\n\naddStyles();\n\n/** Wraps StatefulSandbox for procedurally-generated routing */\nconst Sandbox = (): JSX.Element => <StatefulSandbox />;\n\nclass StatefulSandbox extends React.Component<any, any> {\n  mathField: MathField;\n  constructor(props?: any) {\n    super(props);\n    this.state = {\n      latex: '', // used for initial population\n    };\n    this.mathField = (null as unknown) as MathField; // assigned on mount\n  }\n\n  onChange = (): void => {\n    this.updateState();\n  };\n\n  mathQuillDidMount = (mathField: MathField): void => {\n    this.mathField = mathField;\n    this.updateState();\n  };\n\n  updateState(): void {\n    const latex = this.mathField.latex();\n    const text = this.mathField.text();\n    const mathText = mathwm.texToMath(latex);\n    const node = mathwm.tryParse(mathText);\n    const evaluation =\n      node === null\n        ? 'Invalid expression'\n        : mathwm.evaluate(node, false).toString();\n    super.setState({ latex, text, evaluation });\n  }\n\n  evaluationSteps = (): JSX.Element => {\n    const mathText = mathwm.texToMath(this.state.latex);\n    const node = mathwm.tryParse(mathText);\n    if (node === null) return <p>Invalid expression</p>;\n    const steps = mathwm.steps(node);\n    return (\n      <div>\n        <p>Evaluation steps:</p>\n        <ol>{steps.map(this.step)}</ol>\n      </div>\n    );\n  };\n\n  step = (s: mathwm.Step): JSX.Element => {\n    let rule: rules.Rule = rules.RULES[s.ruleID];\n    return (\n      <li key={s.node.toString()}>\n        {s.node.toString()} ({rule.name}\n        {rule.latex ? (\n          <>\n            : <Latex inline content={rule.latex}></Latex>\n          </>\n        ) : (\n          <></>\n        )}\n        )\n      </li>\n    );\n  };\n\n  render() {\n    return (\n      <div>\n        Enter an expression:{' '}\n        <EditableMathField\n          latex={this.state.latex}\n          onChange={this.onChange}\n          mathquillDidMount={this.mathQuillDidMount}\n        />\n        <br />\n        <div>(Unprocessed) Tex: {this.state.latex}</div>\n        <br />\n        <div>(Processed) MathText: {mathwm.texToMath(this.state.latex)}</div>\n        <br />\n        <div>Evaluation of MathText: {this.state.evaluation}</div>\n        <br />\n        {this.evaluationSteps()}\n      </div>\n    );\n  }\n}\n\nexport default Sandbox;\n","import React from 'react';\nimport { Route } from 'react-router-dom';\n\nimport Home from './pages/Home';\nimport About from './pages/About';\nimport Algebra from './pages/classes/Algebra';\nimport Preliminaries from './pages/classes/alg/Preliminaries';\nimport IntegerExponents from './pages/classes/alg/01_preliminaries/IntegerExponents';\nimport Sandbox from './pages/Sandbox';\n\nconst Routes = (props: { routes: RouteObject[] }): JSX.Element => (\n  <div>{props.routes.map(element => recursiveRoute(element, ''))}</div>\n);\n\nexport class RouteObject {\n  id: string;\n  name: string;\n  path: string;\n  component: (() => JSX.Element) | null;\n  children: RouteObject[];\n  constructor(\n    id: string,\n    name: string,\n    path: string,\n    component: (() => JSX.Element) | null,\n    children: RouteObject[],\n  ) {\n    this.id = id;\n    this.name = name;\n    this.path = path;\n    this.component = component;\n    this.children = children;\n  }\n}\n\nexport const routes: RouteObject[] = [\n  new RouteObject('0', 'Home', '', Home, []),\n  new RouteObject('1', 'About', 'About', About, []),\n  new RouteObject('2', 'Classes', 'Classes', null, [\n    new RouteObject('3', 'Algebra', 'Alg', Algebra, [\n      new RouteObject('5', 'Preliminaries', 'Preliminaries', Preliminaries, [\n        new RouteObject(\n          '4',\n          'Integer Exponents',\n          'IntegerExponents',\n          IntegerExponents,\n          [],\n        ),\n      ]),\n    ]),\n  ]),\n  new RouteObject('6', 'Sandbox', 'Sandbox', Sandbox, []),\n];\n\n/**\n * Returns the absolute path to the component, if it exists. Otherwise, returns\n * the absolute path to 404. Used globally to generate paths in links.\n * @param component The component to route to\n * @param routeObjects may contain RouteObject corresponding to component\n * @param pathTo404 path to return in case there is no corresponding RouteObject\n */\nexport function path(\n  component: () => JSX.Element,\n  routeObjects = routes,\n  pathTo404 = '',\n): string {\n  let potentialPath = pathHelper(component, '', routeObjects);\n  return potentialPath !== null ? potentialPath : pathTo404;\n}\n\n/**\n * Searches recursively through `routeObjects`, looking for an object whose\n * component matches `component`. If one is found, returns the path to that\n * `routeObject`. Else, returns null.\n * @param component the component to path to\n * @param partialPath the path generated so far\n * @param routeObjects\n * @return path to component, or null if no match found\n */\nfunction pathHelper(\n  component: () => JSX.Element,\n  partialPath: string,\n  routeObjects: RouteObject[],\n): string | null {\n  let basePath = partialPath; // must save base before repeatedly updating\n  for (let routeObject of routeObjects) {\n    partialPath = `${basePath}/${routeObject.path}`;\n    if (routeObject.component === component) return partialPath; // found match\n    // no match here, search children of this RouteObject\n    let childrenResult = pathHelper(\n      component,\n      partialPath,\n      routeObject.children,\n    );\n    if (childrenResult !== null) return childrenResult;\n    // no match in these children, start again with next element in list\n  }\n  return null;\n}\n\n/**\n * Returns a div containing a `Route` for each of this `RouteObject` and this\n * `RouteObject`'s descendants\n * @param routeObject\n * @param basePath\n */\nfunction recursiveRoute(routeObject: RouteObject, basePath: string): JSX.Element {\n  let fullPath = `${basePath}/${routeObject.path}`;\n  return (\n    <div key={routeObject.id}>\n      {routeObject.component ? route(routeObject, fullPath) : ''}\n      {routeObject.children.map(child => recursiveRoute(child, fullPath))}\n    </div>\n  );\n}\n\n/**\n * Returns the `Route` corresponding to the given `RouteObject` and `path`.\n * Does not return the route for any children\n * @param routeObject\n * @param path\n * @precondition `typeof(routeObject.component) === '() => JSX.Element'`\n */\nfunction route(routeObject: RouteObject, path: string): JSX.Element {\n  return (\n    <Route\n      key={routeObject.id}\n      exact\n      path={path}\n      component={routeObject.component as () => JSX.Element}\n    ></Route>\n  );\n}\n\nexport default Routes;\n","import React from 'react';\nimport { HashRouter } from 'react-router-dom';\n\nimport ConstructionAlert from './ConstructionAlert';\nimport Navigation from './Navigation';\nimport Routes, { routes } from './Routes';\n\nconst App = (): JSX.Element => (\n  <div>\n    <ConstructionAlert />\n    <HashRouter>\n      <Navigation routes={routes} />\n      <Routes routes={routes} />\n    </HashRouter>\n  </div>\n);\n\nexport default App;\n","import React from 'react';\nimport { render } from 'react-dom';\n\nimport App from './App';\n\nrender(<App />, document.getElementById('root'));\n"],"sourceRoot":""}